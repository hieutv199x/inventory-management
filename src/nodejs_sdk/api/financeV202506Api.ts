/**
 * tiktok shop openapi
 * sdk for apis
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Finance202506GetSellerunsettledtransactionResponse } from '../model/finance/V202506/GetSellerunsettledtransactionResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://open-api.tiktokglobalshop.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum FinanceV202506ApiApiKeys {
}

export class FinanceV202506Api {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static readonly apiName = 'FinanceV202506Api' as const;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: FinanceV202506ApiApiKeys, value: string) {
        (this.authentications as any)[FinanceV202506ApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This API allows the partner to retrieve a list of unsettled transactions (incl. Orders & Adjustments) generated by a seller, returning the detailed fee breakdown for a list of order ID and adjustment ID.  For now, this API only returns transactions which were created after 2025.01.01. Once one transaction is settled, which won\'t be returned by this API anymore, please get from Get Statement Transaction API.  **Pay attention to that all data returned through this API is an estimated amount which subject to change before settlement and can only used for seller\'s reference, final settlement amount per each transaction can only provided through statement related API.
     * @summary GetSellerunsettledtransaction
     * @param sortField The returned results will be sorted by the specified field. Only supports &#x60;order_create_time&#x60;.
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param pageToken An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
     * @param pageSize The number of results to be returned per page.  Default: 20 Valid range: [1-100]
     * @param sortOrder The sort order for the &#x60;sort_field&#x60; parameter.  Default: ASC  Possible values: - ASC: Ascending order - DESC: Descending order
     * @param searchTimeGe Filter statements to show only those that are generated on or after the specified date and time. Unix timestamp. Note: statement_time_ge and statement_time_le together constitute the creation time filter condition. - If statement_time_ge is filled but statement_time_lt is empty, statement_time_lt will default to the current time. - If statement_time_lt is filled but statement_time_ge is empty, statement_time_ge will default to the earliest shop time. Example: As statements are generated daily at 00:00 UTC, to retrieve statements for the period from Oct 5 to Oct 10, configure the parameters as follows: - Set statement_time_ge to 00:00 on Oct 6  or any time on Oct 5 (excluding 00:00). - Set statement_time_lt to any time on Oct 11 (excluding 00:00).
     * @param searchTimeLt the search range\&#39;s end time
     */
    public async UnsettledOrdersQueryGet (sortField: string, xTtsAccessToken: string, contentType: string, pageToken?: string, pageSize?: number, sortOrder?: string, searchTimeGe?: string, searchTimeLt?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Finance202506GetSellerunsettledtransactionResponse;  }> {
        const localVarPath = this.basePath + '/finance/202506/unsettled/orders/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sortField' is not null or undefined
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling UnsettledOrdersQueryGet.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling UnsettledOrdersQueryGet.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling UnsettledOrdersQueryGet.');
        }

        if (pageToken !== undefined) {
            localVarQueryParameters['page_token'] = ObjectSerializer.serialize(pageToken, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['page_size'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sort_field'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (searchTimeGe !== undefined) {
            localVarQueryParameters['search_time_ge'] = ObjectSerializer.serialize(searchTimeGe, "string");
        }

        if (searchTimeLt !== undefined) {
            localVarQueryParameters['search_time_lt'] = ObjectSerializer.serialize(searchTimeLt, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Finance202506GetSellerunsettledtransactionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Finance202506GetSellerunsettledtransactionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}

export const FinanceV202506ApiOperationNames = {
    UnsettledOrdersQueryGet: 'UnsettledOrdersQueryGet',
} as const


export type FinanceV202506ApiOperationTypes = {
    UnsettledOrdersQueryGet: FinanceV202506Api['UnsettledOrdersQueryGet'];
};

