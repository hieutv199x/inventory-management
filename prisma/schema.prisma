datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

enum Role {
  OWNER
  RESOURCE
  ACCOUNTANT
  SELLER
}

enum Channel {
  TIKTOK
  AMAZON
  SHOPIFY
  ALIBABA_1688
}

enum AuthorizationStatus {
  ACTIVE    // Đang hoạt động
  EXPIRED   // Đã hết hạn (cần refresh)
  REVOKED   // Đã bị thu hồi
  INACTIVE  // Không hoạt động
}

model UserShopRole {
  id        String   @id @default(cuid()) @map("_id") @db.String
  userId    String   @db.ObjectId
  shopId    String   @db.ObjectId
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  shop ShopAuthorization @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([userId, shopId])
  @@map("user_shop_roles")
}

model User {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  username  String    @unique
  password  String
  role      UserRole  @default(SELLER)
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  sessions  Session[]
  createdBy String?   @db.ObjectId
  creator   User?     @relation("UserCreator", fields: [createdBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
  createdUsers User[] @relation("UserCreator")
  
  // Bank relations
  uploadedBanks BankAccount[] @relation("BankUploader")
  assignedBanks BankAccount[] @relation("BankAssignee")
  bankHistoryActions BankHistory[]

  userShopRoles UserShopRole[]

  notifications Notification[]

  // Scheduler relations
  createdJobs     SchedulerJob[]
  schedulerConfigs SchedulerConfig[]
}

enum UserRole {
  ADMIN
  MANAGER
  RESOURCE
  ACCOUNTANT
  SELLER
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @db.ObjectId
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
  sessionToken String   @unique
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String   @unique
  expires    DateTime
}

model ChannelApp {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  appName   String   // Descriptive name for the app
  channel   Channel  // Which channel this app belongs to
  appId     String
  appKey    String   @unique // Unique key for the app
  appSecret String   // App secret
  appUrl    String?  // Optional URL for the app
  
  // Channel-specific configuration (JSON string)
  config    String?  // Store channel-specific settings as JSON

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)

  // Relations to unified authorization
  authorizations ShopAuthorization[]
  
  @@map("channel_apps")
}

// Remove TikTokApp - migrate to ChannelApp

// Rename and expand ShopAuthorization to support all channels
model ShopAuthorization {
  id         String  @id @default(auto()) @map("_id") @db.ObjectId

  // Relation to TiktokUnsettledTransaction
  tiktokUnsettledTransactions TiktokUnsettledTransaction[] 

  managedName String? // For TikTok: managed shop ID (if applicable)

  // Universal shop identification
  shopId     String  @unique // Universal shop ID (TikTok shop ID, Amazon seller ID, etc.)
  shopName   String? // Name of the shop/store
  
  // Legacy fields (for migration compatibility)
  shopCipher String? // TikTok shopCipher (will be moved to channelData)
  region     String? // TikTok region (will be moved to channelData)
  
  // Channel-specific identifiers (JSON object) - make optional for migration
  channelData String? // Store channel-specific data as JSON
  // Examples:
  // TikTok: {"shopCipher": "xxx", "region": "VN"}
  // Amazon: {"marketplaceId": "xxx", "sellerId": "xxx", "region": "US"}
  // Shopify: {"shopDomain": "mystore.myshopify.com"}
  // Alibaba: {"memberId": "xxx"}

  // Authorization tokens and credentials
  accessToken  String   // Primary access token
  refreshToken String?  // Refresh token (if applicable)
  expiresIn    Int?     // Token expiration time in seconds
  scope        String?  // Granted permissions/scopes
  
  // Additional credentials for channels that need them (JSON)
  credentials  String?  // Store additional credentials as JSON
  // Examples:
  // Amazon: {"secretKey": "xxx", "mwsAuthToken": "xxx"}
  // Others can store additional auth data here

  status    AuthorizationStatus @default(ACTIVE)

  // Relations - make appId optional for migration
  appId String?   @db.ObjectId
  app   ChannelApp? @relation(fields: [appId], references: [id], onDelete: Cascade)
  
  // Bank relations
  bankAccounts BankAccount[]
  
  // Universal relations (will work for all channels)
  payments     Payment[]
  statements   Statement[]
  withdrawals  Withdrawal[]
  orders       Order[]
  products     Product[]
  conversations Conversation[]

  userShopRoles UserShopRole[]

  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("shop_authorizations")
}

// Update Product model to be channel-agnostic
model Product {
  id                         String  @id @default(auto()) @map("_id") @db.ObjectId
  productId                  String  @unique // Universal product ID
  
  // Channel and shop information - make optional for migration
  channel                    Channel? // Which channel this product belongs to
  shopId                     String? @db.ObjectId
  shop                       ShopAuthorization? @relation(fields: [shopId], references: [id])

  // Universal product fields
  title                      String
  description                String
  status                     String
  
  // Channel-specific data (JSON object)
  channelData                String? // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"isNotForSale": true, "isCodAllowed": false, "isPreOwned": false, "shippingInsuranceRequirement": "xxx"}
  // Amazon: {"asin": "B07XXX", "parentAsin": "B07YYY", "category": "Electronics"}
  // Shopify: {"vendor": "Nike", "productType": "Shoes", "tags": ["summer", "sale"]}
  // Alibaba: {"category": "Machinery", "moq": 100}
  
  // Pricing information (can vary by channel)
  price                      String?
  currency                   String?
  
  // Timing
  createTime                 Int?
  updateTime                 Int?

  // Existing relations (keep for TikTok compatibility)
  brandId                    String? @map("brand_id") @db.ObjectId
  auditId                    String?  @unique @map("audit_id") @db.ObjectId
  brand                      Brand?  @relation(fields: [brandId], references: [id])
  audit                      Audit?  @relation(fields: [auditId], references: [id])

  dimensions                 PackageDimension?
  weight                     PackageWeight?
  skus                       Sku[]
  categories                 CategoryChain[]
  images                     ProductImage[]
  attributes                 ProductAttribute[]

  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
}

model Brand {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  brandId   String   @unique
  name      String
  products  Product[]
}

model Audit {
  id                 String   @id @default(auto()) @map("_id") @db.ObjectId
  status             String
  preApprovedReasons String[]
  failedReasons      String[]
  suggestions        String[]
  product            Product?
}

model PackageDimension {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  productId String   @unique @db.ObjectId
  height    String
  length    String
  width     String
  unit      String
  product   Product  @relation(fields: [productId], references: [id])
}

model PackageWeight {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  productId String   @unique @db.ObjectId
  value     String
  unit      String
  product   Product  @relation(fields: [productId], references: [id])
}

model CategoryChain {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  productId  String   @db.ObjectId
  categoryId String
  localName  String
  parentId   String
  isLeaf     Boolean
  product    Product  @relation(fields: [productId], references: [id])

  @@unique([productId, categoryId])
}

model ProductImage {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  productId  String   @db.ObjectId
  uri        String
  width      Int
  height     Int
  urls       String[]
  thumbUrls  String[]
  product    Product  @relation(fields: [productId], references: [id])
}

model ProductAttribute {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  productId  String   @db.ObjectId
  attrId     String
  name       String
  values     AttributeValue[]
  product    Product  @relation(fields: [productId], references: [id])

  @@unique([productId, attrId])
}

model AttributeValue {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  productAttributeId  String   @db.ObjectId
  valueId             String
  name                String
  productAttribute    ProductAttribute @relation(fields: [productAttributeId], references: [id])

  @@unique([productAttributeId, valueId])
}

model Sku {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  skuId        String   @unique
  productId    String   @db.ObjectId
  sellerSku    String
  price        Price?
  inventory    Inventory[]
  product      Product  @relation(fields: [productId], references: [id])
  channelData                    String?
}

model Price {
  id                 String   @id @default(auto()) @map("_id") @db.ObjectId
  skuId              String   @unique @db.ObjectId
  currency           String
  salePrice          String
  taxExclusivePrice  String
  sku                Sku     @relation(fields: [skuId], references: [id])
}

model Inventory {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  skuId      String   @db.ObjectId
  quantity   Int
  warehouseId String
  sku        Sku     @relation(fields: [skuId], references: [id])
  channelData                    String?
  @@unique([skuId, warehouseId])
}

model BankAccount {
  id            String     @id @default(auto()) @map("_id") @db.ObjectId
  accountNumber String
  routingNumber String
  swiftCode     String
  bankName      String
  accountHolder String
  status        BankStatus @default(UNUSED)
  uploadDate    DateTime   @default(now())
  setupDate     DateTime?
  
  // Relations
  uploaderId    String @db.ObjectId
  uploader      User   @relation("BankUploader", fields: [uploaderId], references: [id])
  
  assigneeId    String? @db.ObjectId
  assignee      User?   @relation("BankAssignee", fields: [assigneeId], references: [id])
  
  shopId        String? @db.ObjectId
  shop          ShopAuthorization? @relation(fields: [shopId], references: [id])

  historyActions BankHistory[]

  @@map("bank_accounts")
}

model BankHistory {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  action    String
  details   String
  timestamp DateTime @default(now())
  
  // Relations
  userId    String @db.ObjectId
  user      User   @relation(fields: [userId], references: [id])
  
  bankId    String? @db.ObjectId
  bank      BankAccount? @relation(fields: [bankId], references: [id])

  @@map("bank_history")
}

enum BankStatus {
  USED
  UNUSED
}


model Payment {
  id                             String   @id @default(auto()) @map("_id") @db.ObjectId

  paymentId                      String   @unique // Universal payment ID
  channel                        Channel? // Which channel this payment belongs to - make optional for migration
  
  // Universal payment fields
  createTime                     Int?
  status                         String
  
  // Amounts (universal structure)
  amountValue                    String?
  amountCurrency                 String?
  settlementAmountValue          String?
  settlementAmountCurrency       String?
  
  // Channel-specific payment data (JSON)
  channelData                    String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"reserveAmountValue": "xx", "paymentBeforeExchangeValue": "xx", "exchangeRate": "xx"}
  // Amazon: {"feeAmount": "xx", "taxAmount": "xx"}
  // Shopify: {"processingFee": "xx", "gateway": "stripe"}

  paidTime                       Int?
  bankAccount                    String?

  // Shop relation (universal) - Fix: use ObjectId reference
  shopId                         String   @db.ObjectId
  shop                           ShopAuthorization @relation(fields: [shopId], references: [id])

  createdAt                      DateTime @default(now())
  updatedAt                      DateTime @updatedAt
  
  @@map("payments")
}

// Rename and unify Statement model
model Statement {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId

  statementId           String   @unique 
  channel               Channel? // Which channel this statement belongs to - make optional for migration
  statementTime         Int?

  // Universal statement fields
  settlementAmount      String?
  currency              String?
  
  // Channel-specific statement data (JSON)
  channelData           String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"revenueAmount": "xx", "feeAmount": "xx", "adjustmentAmount": "xx", "netSalesAmount": "xx"}
  // Amazon: {"productSales": "xx", "shippingCredits": "xx", "refunds": "xx"}
  
  paymentStatus         String?
  paymentId             String?

  // Shop relation (universal) - Fix: use ObjectId reference
  shopId                String   @db.ObjectId
  shop                  ShopAuthorization @relation(fields: [shopId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@map("statements")
}

// Rename and unify Withdrawal model
model Withdrawal {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  withdrawalId  String   @unique
  channel       Channel? // Which channel this withdrawal belongs to - make optional for migration
  
  amount        Float
  status        String
  currency      String
  type          String?
  createTime    Int?
  
  // Channel-specific withdrawal data (JSON)
  channelData   String?  // Store channel-specific fields as JSON
  
  // Shop relation - Fix: use ObjectId reference
  shopId        String   @db.ObjectId
  shop          ShopAuthorization @relation(fields: [shopId], references: [id])
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("withdrawals")
}

// Rename and unify Order model
model Order {
  id                               String   @id @default(auto()) @map("_id") @db.ObjectId
  orderId                          String   @unique // Universal order ID
  channel                          Channel? // Which channel this order belongs to - make optional for migration
  
  // Universal order information
  buyerEmail                       String?
  buyerMessage                     String?
  createTime                       Int?
  updateTime                       Int?
  status                           String
  
  // Universal order amounts
  totalAmount                      String?
  currency                         String?
  
  // Channel-specific order data (JSON)
  channelData                      String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"cancelOrderSlaTime": 123, "isCod": true, "fulfillmentType": "xxx", "trackingNumber": "xxx"}
  // Amazon: {"fulfillmentChannel": "AMAZON", "shipServiceLevel": "Standard"}
  // Shopify: {"financialStatus": "paid", "fulfillmentStatus": "fulfilled"}
  
  // Timing fields (universal)
  paidTime                        Int?
  deliveryTime                    Int?
  
  // Shop relation (universal) - Fix: use ObjectId reference
  shopId                          String   @db.ObjectId
  shop                            ShopAuthorization @relation(fields: [shopId], references: [id])
  
  // Related data (keep existing structure for TikTok compatibility)
  lineItems                       OrderLineItem[]
  packages                        OrderPackage[]
  payment                         OrderPayment?
  recipientAddress                OrderRecipientAddress?

  customStatus                    String?
  
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt

  notifications Notification[]
  tikTokTransactions TikTokTransaction[]
  
  // Add relation to unsettled transactions
  unsettledTransactions TiktokUnsettledTransaction[]
  
  @@map("orders")
}

// Rename TikTokOrderLineItem to OrderLineItem (universal)
model OrderLineItem {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  lineItemId            String   @unique // Universal line item ID
  
  // Universal product information
  productId             String
  productName           String
  skuId                 String?
  skuName               String?
  sellerSku             String?
  
  // Universal pricing information
  currency              String?
  originalPrice         String?
  salePrice             String?
  
  // Channel-specific line item data (JSON)
  channelData           String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"skuType": "xxx", "skuImage": "xxx", "displayStatus": "xxx", "isGift": false}
  // Amazon: {"conditionNote": "xxx", "giftMessage": "xxx"}
  // Shopify: {"variant_id": "xxx", "requires_shipping": true}
  
  // Order relation
  orderId               String   @db.ObjectId
  order                 Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@map("order_line_items")
}

// Rename and keep other order-related models with channel support
model OrderPayment {
  id                                    String   @id @default(auto()) @map("_id") @db.ObjectId
  
  // Universal payment amounts
  currency                              String?
  totalAmount                           String?
  subTotal                              String?
  tax                                   String?
  
  // Channel-specific payment data (JSON)
  channelData                           String?  // Store channel-specific fields as JSON
  
  // Order relation
  orderId                               String   @unique @db.ObjectId
  order                                 Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  createdAt                             DateTime @default(now())
  updatedAt                             DateTime @updatedAt
  
  @@map("order_payments")
}

model OrderRecipientAddress {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  
  // Universal address fields
  fullAddress               String?
  postalCode                String?
  
  // Universal name information
  name                      String?
  phoneNumber               String?
  
  // Channel-specific address data (JSON)
  channelData               String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"addressDetail": "xxx", "regionCode": "xxx", "firstName": "xxx"}
  // Amazon: {"addressLine1": "xxx", "city": "xxx", "state": "xxx"}
  // Shopify: {"company": "xxx", "province": "xxx", "country": "xxx"}
  
  // Order relation
  orderId                   String   @unique @db.ObjectId
  order                     Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  // District information (keep for TikTok compatibility)
  districtInfo              AddressDistrict[]
  
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  
  @@map("order_recipient_addresses")
}

model AddressDistrict {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  
  addressLevel              String   // "L0", "L1", "L2", "L3"
  addressLevelName          String   // "Country", "province", "city", "ward"
  addressName               String
  
  // Recipient address relation
  recipientAddressId        String   @db.ObjectId
  recipientAddress          OrderRecipientAddress @relation(fields: [recipientAddressId], references: [id], onDelete: Cascade)
  
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  
  @@map("address_districts")
}

model OrderPackage {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  packageId                 String   // Package ID from channel
  
  // Channel-specific package data (JSON)
  channelData               String?  // Store channel-specific fields as JSON
  
  // Order relation
  orderId                   String   @db.ObjectId
  order                     Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  
  @@unique([orderId, packageId])
  @@map("order_packages")
}

// Rename and unify Conversation model
model Conversation {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  conversationId    String   @unique // Universal conversation ID
  channel           Channel? // Which channel this conversation belongs to - make optional for migration
  
  // Universal conversation fields
  participantCount  Int?
  canSendMessage    Boolean?
  unreadCount       Int?
  createTime        Int?
  
  // Channel-specific conversation data (JSON)
  channelData       String?  // Store channel-specific fields as JSON
  
  // Shop relation - Fix: use ObjectId reference
  shopId            String   @db.ObjectId
  shop              ShopAuthorization @relation(fields: [shopId], references: [id])
  
  // Related data
  participants      ConversationParticipant[]
  messages          ConversationMessage[]
  latestMessage     ConversationMessage? @relation("LatestMessage")

  notifications Notification[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("conversations")
}

model ConversationParticipant {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  participantId     String   // Universal participant ID (im_user_id, customer_id, etc.)
  userId            String?  // Platform-specific user ID
  role              String   // "BUYER", "SELLER", etc.
  nickname          String?
  avatar            String?
  
  // Channel-specific participant data (JSON)
  channelData       String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"buyerPlatform": "TIKTOK_SHOP"}
  // Amazon: {"buyerName": "xxx"}
  
  // Conversation relation
  conversationId    String   @db.ObjectId
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  // Messages sent by this participant
  sentMessages      ConversationMessage[] @relation("MessageSender")
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@unique([conversationId, participantId])
  @@map("conversation_participants")
}

model ConversationMessage {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  messageId         String   @unique // Universal message ID
  type              String?  // "TEXT", "IMAGE", "ORDER", etc.
  content           String?  // Message content or JSON string
  createTime        Int?
  isVisible         Boolean?
  
  // Channel-specific message data (JSON)
  channelData       String?  // Store channel-specific fields as JSON
  // Examples:
  // TikTok: {"messageIndex": "xxx"}
  // Others can store specific message metadata
  
  // Conversation relation
  conversationId    String   @db.ObjectId
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  // Sender relation
  senderId          String?  @db.ObjectId
  sender            ConversationParticipant? @relation("MessageSender", fields: [senderId], references: [id])
  
  // Latest message relation (one-to-one)
  isLatestFor       Conversation? @relation("LatestMessage", fields: [isLatestForId], references: [id])
  isLatestForId     String? @unique @db.ObjectId
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("conversation_messages")
}

// New notification models
model Notification {
  id          String            @id @default(auto()) @map("_id") @db.ObjectId
  type        NotificationType
  title       String
  message     String
  data        String?           // JSON string for additional notification data
  read        Boolean           @default(false)
  readAt      DateTime?
  
  // User relation
  userId      String            @db.ObjectId
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional relations based on notification type
  orderId     String?           @db.ObjectId
  order       Order?            @relation(fields: [orderId], references: [id], onDelete: SetNull)
  
  conversationId String?        @db.ObjectId
  conversation   Conversation?  @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  
  shopId      String?           @db.ObjectId
  shop        ShopAuthorization? @relation(fields: [shopId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  @@map("notifications")
}

enum NotificationType {
  NEW_ORDER          // New order received
  ORDER_STATUS_CHANGE // Order status changed
  ORDER_CANCELLED    // Order was cancelled
  ORDER_DELIVERED    // Order was delivered
  NEW_MESSAGE        // New message in conversation
  PAYMENT_RECEIVED   // Payment notification
  LOW_INVENTORY      // Stock running low
  SYSTEM_ALERT       // System notifications
  WEBHOOK_ERROR      // Webhook processing errors
}

model TikTokTransaction {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  transactionId   String?
  shopId          String
  statementId     String?

  type            String           // ORDER, REFUND, ADJUSTMENT...
  currency        String
  createdTime      DateTime?   // from timestamp

  // Financial amounts
  settlementAmount     Float?      // e.g. 130
  adjustmentAmount     Float?      // e.g. 170
  revenueAmount        Float?      // e.g. 200
  shippingCostAmount   Float?      // e.g. -70
  feeTaxAmount         Float?      // e.g. -30
  reserveAmount        Float?      // e.g. 100

  // Order information
  orderId              String?
  order                Order?      @relation(fields: [orderId], references: [orderId])
  
  orderCreateTime      DateTime?   // from timestamp
  adjustmentId         String?
  adjustmentOrderId    String?
  associatedOrderId    String?

  // Reserve info
  reserveId            String?
  reserveStatus        String?     // Collected, Released
  estimatedReleaseTime DateTime?

  // Breakdown fields (kept as JSON for flexibility)
  revenueBreakdown        Json?
  shippingCostBreakdown   Json?
  feeTaxBreakdown         Json?
  supplementaryComponent  Json?

  // Meta
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([shopId, statementId])
  @@index([orderId])
  @@index([type])
  @@index([reserveStatus])
  @@map("tiktok_transactions")
}

model TiktokUnsettledTransaction {
  id                        String    @id @default(auto()) @map("_id") @db.ObjectId
  shopId                    String    @map("shop_id")
  
  // API Response Fields
  transactionId             String    @unique @map("transaction_id") // maps to 'id' from API
  adjustmentId              String?   @map("adjustment_id")
  adjustmentOrderId         String?   @map("adjustment_order_id")
  currency                  String?
  estAdjustmentAmount       String?   @map("est_adjustment_amount")
  estFeeTaxAmount           String?   @map("est_fee_tax_amount")
  estRevenueAmount          String?   @map("est_revenue_amount")
  estSettlementAmount       String?   @map("est_settlement_amount")
  estShippingCostAmount     String?   @map("est_shipping_cost_amount")
  estimatedSettlement       String?   @map("estimated_settlement")
  feeTaxBreakdown           Json?     @map("fee_tax_breakdown")
  orderCreateTime           DateTime? @map("order_create_time")
  orderDeliveryTime         DateTime? @map("order_delivery_time")
  orderId                   String?   @map("order_id")
  revenueBreakdown          Json?     @map("revenue_breakdown")
  shippingCostBreakdown     Json?     @map("shipping_cost_breakdown")
  status                    String?
  type                      String?   // Transaction type (ORDER, CHARGE_BACK, etc.)
  unsettledReason           String?   @map("unsettled_reason")
  
  // Metadata
  createdAt                 DateTime  @default(now()) @map("created_at")
  updatedAt                 DateTime  @updatedAt @map("updated_at")
  
  // Relations
  shop                       ShopAuthorization? @relation(fields: [shopId], references: [shopId])
  
  // Add relation to Order
  order                      Order? @relation(fields: [orderId], references: [orderId])
  
  @@map("tiktok_unsettled_transactions")
  @@index([shopId])
  @@index([type])
  @@index([status])
  @@index([orderCreateTime])
  @@index([orderId])
  @@index([adjustmentId])
}

// Scheduler models
enum JobType {
  FUNCTION_CALL     // Call internal function
  API_CALL          // Call external/internal API
  DATABASE_QUERY    // Execute database operations
  WEBHOOK_TRIGGER   // Send webhook
}

enum JobStatus {
  ACTIVE
  INACTIVE
  PAUSED
  DELETED
}

enum ExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  CANCELLED
  TIMEOUT
}

enum TriggerType {
  CRON           // Cron expression
  INTERVAL       // Fixed interval
  ONE_TIME       // Single execution
  EVENT_DRIVEN   // Triggered by events
}

model SchedulerJob {
  id              String        @id @default(auto()) @map("_id") @db.ObjectId
  name            String        // Job name
  description     String?       // Job description
  type            JobType       // Type of job
  status          JobStatus     @default(ACTIVE)
  
  // Trigger configuration
  triggerType     TriggerType
  cronExpression  String?       // For CRON type: "0 */5 * * * *"
  intervalMinutes Int?          // For INTERVAL type: minutes
  scheduledAt     DateTime?     // For ONE_TIME type
  
  // Job configuration (JSON) - can include shopId in the config if needed
  config          String        // Job-specific configuration as JSON
  // Examples:
  // FUNCTION_CALL: {"function": "syncOrders", "params": {"shopId": "xxx"}}
  // API_CALL: {"url": "https://api.example.com/sync", "method": "POST", "headers": {...}, "body": {...}}
  // DATABASE_QUERY: {"operation": "updateMany", "model": "product", "where": {...}, "data": {...}}
  
  // Execution settings
  timeout         Int?          @default(300000) // Timeout in milliseconds (5 minutes default)
  retryCount      Int?          @default(3)      // Number of retries on failure
  retryDelay      Int?          @default(60000)  // Delay between retries in milliseconds
  
  // Tags for categorization and filtering
  tags            String[]      @default([])     // Array of tags for organization
  
  // Metadata
  createdBy       String?       @db.ObjectId
  creator         User?         @relation(fields: [createdBy], references: [id])
  
  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  lastExecutedAt  DateTime?     // Last successful execution
  nextExecutionAt DateTime?     // Next scheduled execution
  
  // Relations
  executions      JobExecution[]
  logs            JobLog[]
  
  @@map("scheduler_jobs")
}

model JobExecution {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  jobId           String          @db.ObjectId
  job             SchedulerJob    @relation(fields: [jobId], references: [id], onDelete: Cascade)
  
  // Execution details
  status          ExecutionStatus @default(PENDING)
  startedAt       DateTime?       // When execution started
  completedAt     DateTime?       // When execution completed
  duration        Int?            // Execution duration in milliseconds
  
  // Result and error information
  result          String?         // Success result (JSON)
  error           String?         // Error message if failed
  stackTrace      String?         // Full stack trace for debugging
  
  // Retry information
  retryCount      Int             @default(0)
  isRetry         Boolean         @default(false)
  parentExecutionId String?       @db.ObjectId
  parentExecution JobExecution?   @relation("ExecutionRetries", fields: [parentExecutionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  retries         JobExecution[]  @relation("ExecutionRetries")
  
  // Metadata
  triggeredBy     String?         // How was this execution triggered
  executionContext String?        // Additional context (JSON)
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  @@map("job_executions")
}

model JobLog {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  jobId           String          @db.ObjectId
  job             SchedulerJob    @relation(fields: [jobId], references: [id], onDelete: Cascade)
  
  executionId     String?         @db.ObjectId
  
  // Log details
  level           LogLevel        @default(INFO)
  message         String
  data            String?         // Additional log data (JSON)
  
  timestamp       DateTime        @default(now())
  
  @@map("job_logs")
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
}

model SchedulerConfig {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  
  // Global scheduler settings
  isEnabled       Boolean         @default(true)
  maxConcurrentJobs Int           @default(10)
  defaultTimeout  Int             @default(300000) // 5 minutes
  cleanupDays     Int             @default(30)     // Days to keep execution history
  
  // Notification settings
  notifyOnFailure Boolean         @default(true)
  notifyOnSuccess Boolean         @default(false)
  notificationChannels String?    // JSON array of notification channels
  
  // Metadata
  updatedBy       String?         @db.ObjectId
  updatedUser     User?           @relation(fields: [updatedBy], references: [id])
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  @@map("scheduler_config")
}
